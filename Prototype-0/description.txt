We are creating a web app with an API backend that essentially works like an augmented version of Poe.com but its foundations can be very primitive.
For example it will not need the ability to establish users, log on, or authenticate. It is for demo purposes.
And furthermore, it will only be interfacing with an using one underlying AI system. Which basically amounts to github.com/ruvnet/claude-flow which is being used at this very moment to create the web app. And yet that very same foundation will be invoked under the
hood to represent the underlying AI processing. So this web app has the following kinds of I/O. Firstly, a generic question and answer like prompt just as most LLM UIs have.
Secondly, basically a fixed API that allows for basic things like the ingestion of data - input format may be JSON and the output would be some local file on the system - which claude-flow and its invoked tooling would refer to. Now by virtue of having claude-flow access, that tool could write or leverage arbitrary Python code - as an example language - to do some basic computation and creation of
visual output based upon the data that has been ingested. So there is a notion of really primitive file-based scratch space. So to reiterate, we have like a poe.com which is simplified in many ways - geared toward a MVP/demo and one user that is perpetually logged on.
And the main UI is very much like existing LLM chatbots and that output is fed into claude-flow. So claude-flow is the underlying AI system and LLM. And a core interface on this web app simply passes the info into claude-flow which is able to reference the server system local directory and data and code, and it is also able to run arbitrary code. We also have a JSON API for data ingestion which can do simple things like nominally writing the output to a file. Let us suppose the web app can render some very primitive image, which lets us have some form of visualisation. So some python code is run that generates a visual.
So we will build this out carefully, in a modular way, focusing on simplicity and a MVP. Ensure your approach includes ample testing to ensure the result works. By all means, let this particular invocation work hard and relentlessly, performing maximum steps needed until you reach some stumbling block. Use Git commits to keep track of your progress as you reach sub-milestones
